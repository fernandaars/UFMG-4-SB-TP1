\documentclass[
    12pt,               % tamanho da fonte
    a4paper,            % tamanho do papel. 
    oneside,
    english,            % idioma adicional para hifenização
    french,             % idioma adicional para hifenização
    spanish,            % idioma adicional para hifenização
    brazil              % o último idioma é o principal do documento
    ]{abntex2}


\usepackage{lmodern}            % Usa a fonte Latin Modern          
\usepackage[T1]{fontenc}        % Selecao de codigos de fonte.
\usepackage[utf8]{inputenc}     % Codificacao do documento 
\usepackage{lastpage}           % Usado pela Ficha catalográfica
\usepackage{indentfirst}        % Indenta o primeiro parágrafo de cada seção.
\usepackage{color}              % Controle das cores
\usepackage{graphicx}           % Inclusão de gráficos
\usepackage{microtype}          % para melhorias de justificação
\usepackage{hyperref}   % Para Inclusão de Links Externos


\usepackage[brazilian,hyperpageref]{backref}     % Paginas com as citações na bibl
\usepackage[alf]{abntex2cite}   % Citações padrão ABNT


\renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
\renewcommand{\backref}{}
\renewcommand*{\backrefalt}[4]{
    \ifcase #1 %
        Nenhuma citação no texto.%
    \or
        Citado na página #2.%
    \else
        Citado #1 vezes nas páginas #2.%
    \fi}%


\titulo{Trabalho Prático 1:\\ Entregando Lanches}
\autor{Fernanda Aparecida Rodrigues Silva}
\local{Belo Horizonte}
\data{21 de Maio de 2017}
\instituicao{%
	Universidade Federal de Minas Gerais - UFMG 
	\par
	Departamento de Ciência da Computação
	\par 
	Curso de Bacharelado em Ciência da Computação}
\tipotrabalho{Trabalho Acadêmico}

\preambulo{Documentação do Trabalho Prático 1: Entregando Lanches da Disciplina de Algoritmos e Estruturas de Dados III.}

\makeatletter
\hypersetup{
        %pagebackref=true,
        pdftitle={\@title}, 
        pdfauthor={\@author},
        pdfsubject={\imprimirpreambulo},
        pdfcreator={LaTeX with abnTeX2},
        pdfkeywords={abnt}{latex}{abntex}{abntex2}{trabalho acadêmico}, 
        colorlinks=true,            % false: boxed links; true: colored links
        linkcolor=blue,             % color of internal links
        citecolor=blue,             % color of links to bibliography
        filecolor=magenta,              % color of file links
        urlcolor=blue,
        bookmarksdepth=4
}
\makeatother

\setlength{\parindent}{1.3cm}
\setlength{\parskip}{0.2cm}  
\makeindex

\begin{document}

\frenchspacing 
\imprimircapa
\imprimirfolhaderosto*

\textual

\section*{Introdução}

	O problema proposto pelo \textit{Trabalho Prático 1: Entregando Lanches} define-se por, dado um sitema de franquias de entrega de lanches via bicicletas e um conjunto de clientes, na descoberta do número máximo de ciclistas que podem trafegar em uma cidade. A cidade, nesse caso, é composta exclusivamente por um conjunto de ciclovias e suas interseções, onde todos as franquias e clientes estão, sem exceções, localizados em interseções. Em caráter de restrição, o problema apresenta também que existe uma capacidade fixa de ciclistas que cada ciclovia pode comportar.
	
	Definido o problema, têm-se como entrada do algoritmo, primeiramente, o número de interseções, ciclovias, franquias e clientes. Posteriormente, são informadas quais são as ciclovias, com as interseções que elas conectam e suas respectivas capacidades, as franquias e os clientes.
	
\section*{Solução do Problema}

	A resolução do problema deu-se, em primeiro passo, na definição da estrutura de dados na qual foram modelados as informações dadas como entrada. Escolheu-se usar a modelagem em grafos, onde arestas representam ciclovias e vértices são interseções.
	
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.6]{1.png}
\caption{Definição da Estrutura TipoGrafo em GRAFO.h}
\end{figure}
	
	Em sequência, reconheceu-se no problema similaridades com o problema clássico de \textit{Maximum Flow}, onde dado dois vértices - o \textit{source} e o \textit{sink} - em um grafo orientado e ponderado, deve-se encontrar qual o fluxo máximo que pode ser "enviado" do \textit{source} para \textit{sink} através das arestas. 
	
	Na literatura existem alguns algoritmos que resolvem o problema de fluxo máximo, entre eles escolheu-se usar o Algoritmo de\textit{Edmonds-Karp}, que alia a simplicidade de implementação à técnica de \textit{Breadth First Search}, já estudada anteriormente na disciplina.
	
	O algoritmo de \textit{Edmonds-Karp} funciona através da descoberta sucessiva de caminhos entre os vértices \textit{source} e \textit{sink}, por onde manda-se fluxo igual à mínima capacidade das arestas que o compõem. A cada fluxo enviado, o algoritmo atualiza arestas de retorno, que são definidas em sentido reverso ao das arestas do caminho. A condição de parada do \textit{Edmonds-Karp} é o momento onde não é possível mais encontrar caminhos entre o \textit{source} e \textit{sink}. Para fornecer o arcabouço necessário para a implementação do algoritmo, definiu-se a entrutura aresta, representada abaixo pelo TipoItem, como sendo:
	 
\begin{figure}[!htb]
\centering
\includegraphics[scale=0.6]{2.png}
\caption{Definição das Estruturas TipoCapacidade, TipoIntersecao e TipoItem em LISTA.h}
\end{figure}

	Por fim, definiu-se como solução global do problema a aplicação do algoritmo de \textit{Edmonds-Karp} para cada par franquia-cliente presente no grafo, de forma que a cada iteração do algoritmo atualiza-se o grafo residual, onde são armazenados os valores de fluxo para cada aresta no momento.	

\section*{Estudo de Complexidade}

	O comportamento assintótico do programa foi analisado com base no aumento do número total de interseções - representado por V - e ciclovias - representado por A. Funções e procedimentos que independem desses parâmetros ou que não são afetadas pelo aumento dos mesmos foram consideradas de complexidade constante, ou seja, O(1).
	
\subsection*{Complexidade Temporal}
\subsubsection*{Funções e Procedimentos de GRAFO.h}
\begin{itemize}

	\item \texttt{void gLibera(TipoGrafo *grafo)}:
	O(1).
	\item \texttt{void gInicializaVertice(TipoItem v1, TipoGrafo *grafo)}:
	O(1).
	\item \texttt{void gInicializa(TipoGrafo *grafo, int numVertices, int  numArestas)}:
	O(V), pois o procedimento inicia V listas de adjacências.
	\item \texttt{void gInsereAresta(TipoItem *v1, TipoItem *v2, bool gDirecionado, bool   		  criarArestaDeRetorno, TipoGrafo *grafo)}:
	O(1).
	
\end{itemize}

\subsubsection*{Funções e Procedimentos de FLUXO.h}
\begin{itemize}

	\item \texttt{int algoritmoEdmondsKarp(TipoItem vOrigem, TipoItem vDestino, 	 TipoGrafo *grafo)}:
	A complexidade da função está relacionada a complexidade clássica do Algoritmo de \textit{Edmonds-Karp} que é O(V$A^2$), em decorrência do fato de que cada caminho pode ser encontrado em O(A) e para cada caminho encontrado pelo menos uma das arestas recebe sua capacidade máxima. A distância entre essa aresta, por sua vez, e o \textit{sink} aumenta a cada iteração do algoritmo até atingir o comprimento máximo V.
	\item \texttt{int calculaFluxoMaximo(TipoGrafo *grafo)}:
	A complexidade da função depende do número de franquias e clientes. No pior caso, com V/2 franquias e V/2 clientes, tem-se que a complexidade é O($V^3$ $A^2$). No melhor caso, com o número de fraquias e clientes iguais 1, a complexidade cai para O(V$A^2$).	
		
\end{itemize}

\subsection*{Complexidade Espacial}
\subsubsection*{Funções e Procedimentos de GRAFO.h}
\begin{itemize}

	\item \texttt{void gLibera(TipoGrafo *grafo)}:
	O(1).	
	\item \texttt{void gInicializaVertice(TipoItem v1, TipoGrafo *grafo)}:
	O(1).	
	\item \texttt{void gInicializa(TipoGrafo *grafo, int numVertices, int  numArestas)}:
	O(V), pois o procedimento aloca V listas de adjacências.	
	\item \texttt{void gInsereAresta(TipoItem *v1, TipoItem *v2, bool gDirecionado, bool   		  criarArestaDeRetorno, TipoGrafo *grafo)}:
	O(1).
	
\end{itemize}

\subsubsection*{Funções e Procedimentos de FLUXO.h}
\begin{itemize}

	\item \texttt{int algoritmoEdmondsKarp(TipoItem vOrigem, TipoItem vDestino, 	 TipoGrafo *grafo)}:
	A complexidade espacial da função também está relacionada a complexidade clássica do Algoritmo de \textit{Edmonds-Karp} que é O(V$A^2$)
	\item \texttt{int calculaFluxoMaximo(TipoGrafo *grafo)}:
	O(1).	
		
\end{itemize}
\subsection*{Programa Principal}

	Para a definição da complexidade temporal e espacial do programa principal do trabalho, aplicou-se a regra da soma para todas as funções e procedimentos que são utilizadas direta ou indiretamente por ele. Dessa forma, obteve-se O($V^3$ $A^2$) como complexidade temporal e como complexidade espacial.

\section*{Análise Experimental}

	Para a realização dos testes do sistema, foram utilizados os casos de testes disponibilizados pelos monitores. O resultado dos testes pode ser visto no gráfico abaixo:
	
	\begin{figure}[!htb]
\centering
\includegraphics[scale=0.6]{3.png}
\caption{Gráfico do Tempo de Execução Para os Testes Toy}
\end{figure}

	O melhor caso do algoritmo é estritamente caracterizado por grafos esparços, com poucos vértices e que representam uma configuração de um problema com poucas franquias e poucos clientes. Dentre esses fatores, o número de franquias e clientes é o que tem mais interferência, pois é a soma de ambos que define a quantidade de vezes nas quais o algoritmo de \textit{Edmonds-Karp} é executado. Por sua vez, grafos densos, com muitos vértices e com um grande número de franquias e clientes caracteriza o pior caso.
	
\section*{Conclusão}

	Por fim, concluo que o trabalho desenvolvido foi de imensa ajuda na
compreensão dos conceitos ensinados em sala de aula, fazendo possível utilizar de
estruturas complexas como grafos e algoritmos famosos como o \textit{Edmonds-Karp}.

\chapter*{Bibliografia}

\begin{itemize}
\item Edmonds, Jack; Karp, Richard M. (1972). "Theoretical improvements in algorithmic efficiency for network flow problems". Journal of the ACM. Association for Computing Machinery. 19 (2): 248–264.
\item Ziviani, Nivio. Projeto de algoritmos: com implementações em Pascal e C. Vol. 2.
Thomson, 2004.
\end{itemize}

\chapter*{Anexos}
\begin{itemize}
\item \textbf{LISTA.h}
\item \textbf{LISTA.c}
\item \textbf{GRAFO.h}
\item \textbf{GRAFO.c}
\item \textbf{FLUXO.h}
\item \textbf{FLUXO.c}
\item \textbf{main.c}
\item \textbf{Makefile}
\end{itemize}

\end{document}